<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Control Panel</title>
    <style>
        body {
            font-family: 'Aptos', 'Helvetica Neue', Arial, sans-serif;
            margin: 20px;
        }
        h1 {
            text-align: center;
            margin-top: 20px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 5px;
            text-align: left;
            font-size: 12px;
            white-space: nowrap;
        }
        th {
            background-color: #f2f2f2;
            text-align: center;
        }
        td:nth-child(2), td:nth-child(4), td:nth-child(5), td:nth-child(6), td:nth-child(7), td:nth-child(8), td:nth-child(9), td:nth-child(10) {
            text-align: center;
        }
        td:nth-child(3) {
            text-align: center;
        }
        pre {
            background-color: #f4f4f4;
            padding: 10px;
            border-radius: 5px;
            overflow-x: auto;
        }
        .status-up {
            background-color: #90ee90; // green
            color: white;
        }
        .status-down {
            background-color: red;
            color: white;
        }
        .status-grace {
            background-color: orange;
            color: white;
        }
        note {
            margin-top: 20px;
            font-style: italic;
            font-size: 14px;
        }
    </style>
</head>
<body>

    <h1>Control Panel</h1>

    <div id="horaActual" style="text-align: right; font-size: 14px; color: blue; font-weight: bold; margin-bottom: 10px;"></div>

    <div id="textoIntervalo" style="font-size: 11px; text-align: right; color: #808080;"></div>

    <table id="dataTable">
        <thead>
            <tr>
               <th onclick="sortTable(0)">Name</th>
                <th>Next in:</th>
                <th>Next check</th>
                <th>Last was:<br>(time ago)</th>
                <th>Last check</th>
                <th>#<br>pings:</th>
                <th>Running<br>time:</th>
            </tr>
        </thead>
        <tbody id="jsonTableBody"></tbody>
    </table>
    <note> <b><u>Note:</u></b> If the expected time between checks (check schedule, period) exceeds 300 days, <b>Next check</b> and <b>Next in</b> are <u>intentionally omitted</u>.</note>


    <script>

        var intervalo_refresco = 5000;  // indicar aqui el intervalo de refresco de los datos que se desea (recomendable no inferior a 5 segundos)
        var intervaloEnSegundos = intervalo_refresco / 1000;
        var textoIntervalo = document.getElementById('textoIntervalo');
        textoIntervalo.textContent = 'data updated every ' + intervaloEnSegundos + ' seconds';

        function formatDate(dateString) {
            var options = { 
                day: '2-digit', 
                month: '2-digit', 
                year: '2-digit', 
                hour: '2-digit', 
                minute: '2-digit', 
                second: '2-digit', 
                timeZone: 'Europe/Madrid'
            };

            return new Date(dateString).toLocaleString('es-ES', options);
        }

        function formatElapsedTime(elapsedTime) {
            var days = Math.floor(elapsedTime / (24 * 3600));
            var hours = Math.floor((elapsedTime % (24 * 3600)) / 3600);
            var minutes = Math.floor((elapsedTime % 3600) / 60);
            var seconds = Math.floor(elapsedTime % 60);

            var formattedTime = '';

            if (days > 0) {
                formattedTime += days + 'd ';
            }

            if (hours > 0 || days > 0) {
                formattedTime += hours + 'h ';
            }

            if (minutes > 0 || hours > 0 || days > 0) {
                formattedTime += minutes + 'm ';
            }

            // Muestra segundos solo si el tiempo es inferior a 1 hora
            if (elapsedTime < 3600) {
                formattedTime += seconds + 's';
            }

            return formattedTime.trim();
        }

        function formatTimeUntilNextEvent(timeUntilNextEvent) {
            
            var days = Math.floor(timeUntilNextEvent / (24 * 3600));
            var hours = Math.floor((timeUntilNextEvent % (24 * 3600)) / 3600);
            var minutes = Math.floor((timeUntilNextEvent % 3600) / 60);
            var seconds = Math.floor(timeUntilNextEvent % 60);

            var formattedTime = '';

            if (days > 0) {
                formattedTime += days + 'd ';
            }

            if (hours > 0 || days > 0) {
                formattedTime += hours + 'h ';
            }

            if (minutes > 0 || hours > 0 || days > 0) {
                formattedTime += minutes + 'm ';
            }

            // Muestra segundos solo si el tiempo es inferior a 1 hora
            if (timeUntilNextEvent < 3600) {
                formattedTime += seconds + 's';
            }

            return formattedTime.trim();
        }

        function sortTable(columnIndex) {
            var table, rows, switching, i, x, y, shouldSwitch;
            table = document.querySelector("#dataTable");
            switching = true;

            while (switching) {
                switching = false;
                rows = table.rows;

                for (i = 1; i < rows.length - 1; i++) {
                    shouldSwitch = false;
                    x = rows[i].getElementsByTagName("td")[columnIndex];
                    y = rows[i + 1].getElementsByTagName("td")[columnIndex];

                    if (x.innerHTML.toLowerCase() > y.innerHTML.toLowerCase()) {
                        shouldSwitch = true;
                        break;
                    }
                }

                if (shouldSwitch) {
                    rows[i].parentNode.insertBefore(rows[i + 1], rows[i]);
                    switching = true;
                }
            }
        }

        function fetchDataAndUpdateTable() {
            var httpRequest = new XMLHttpRequest();
            var key = "tkYKFVcRKTR5X8-j_UoYB7zAhz5uBuav"; // Clave API READ-ONLY

            httpRequest.onreadystatechange = function() {
                if (httpRequest.readyState === 4 && httpRequest.status === 200) {
                    var jsonData = JSON.parse(httpRequest.responseText);
                    var tableBody = document.getElementById("jsonTableBody");
                    tableBody.innerHTML = ''; // Limpia las filas existentes

                    // Ordena el array por el nombre antes de mostrarlo
                    jsonData.checks.sort(function(a, b) {
                        return a.name.localeCompare(b.name);
                    });

                    jsonData.checks.forEach(function(check) {
                        var row = document.createElement("tr");

                        var nameCell = document.createElement("td");
                        nameCell.textContent = check.name;
                        
                        // Agrega clases según el estado
                        if (check.status === 'up') {
                            nameCell.classList.add('status-up');
                        } else if (check.status === 'down') {
                            nameCell.classList.add('status-down');
                        } else if (check.status === 'grace') {
                            nameCell.classList.add('status-grace');
                        }

                        row.appendChild(nameCell);
                        
                        // Celdas de Next in y Next check van primero
                        var nextCheckCell = document.createElement("td");
                        var nextPingCell = document.createElement("td");

                        if (check.timeout && check.timeout > 300 * 24 * 3600) {
                            // Si el period, check schedule es mayor que 300 días, no se muestra nada en estas celdas
                            nextPingCell.textContent = " ";
                            nextCheckCell.textContent = " ";
                        } else {
                            var nextPingDate = new Date(check.next_ping);
                            var timeUntilNextEvent = (nextPingDate.getTime() - Date.now()) / 1000;
                            nextPingCell.textContent = formatTimeUntilNextEvent(timeUntilNextEvent);
                            
                            // Reemplaza la fecha según las condiciones
                            if (nextPingDate.toDateString() === new Date().toDateString()) {
                                nextCheckCell.textContent = "Today, " + nextPingDate.toLocaleTimeString();
                            } else if (nextPingDate.toDateString() === new Date(new Date().getTime() + 24 * 3600 * 1000).toDateString()) {
                                nextCheckCell.textContent = "Tomorrow, " + nextPingDate.toLocaleTimeString();
                            } else if (nextPingDate.toDateString() === new Date(new Date().getTime() - 24 * 3600 * 1000).toDateString()) {
                                nextCheckCell.textContent = "Yesterday, " + nextPingDate.toLocaleTimeString();
                            } else {
                                nextCheckCell.textContent = formatDate(check.next_ping);
                            }
                            // Si el status en down, para que no aparezca una fecha tipo 1/1/1970 en Next Check, lo dejo en blanco y pinto de rojo
                            if (check.status === 'down') {
                               nextCheckCell.textContent = " ";
                               nextCheckCell.classList.add('status-down');
                            }
                            // Colorea en naranja la columna "Next in" si está en estado grace y en rojo y escribe down si está en estado down
                            if (check.status === 'grace') {
                                nextPingCell.classList.add('status-grace');
                                nextPingCell.textContent = " ";
                            }
                               if (check.status === 'down') {
                                nextPingCell.classList.add('status-down');
                                nextPingCell.textContent = "down";
                            }
                        }

                        row.appendChild(nextPingCell);
                        row.appendChild(nextCheckCell);

                        // Celda para el tiempo transcurrido (Last was)
                        var elapsedTimeCell = document.createElement("td");
                        elapsedTimeCell.textContent = check.last_ping ? formatElapsedTime((Date.now() - new Date(check.last_ping).getTime()) / 1000) : " ";
                        row.appendChild(elapsedTimeCell);

                        // Celda centrada para la fecha (Last check)
                        var lastPingCell = document.createElement("td");
                        var lastPingDate = check.last_ping ? new Date(check.last_ping) : null;

                        // Reemplaza la fecha según las condiciones
                        if (lastPingDate) {
                            if (lastPingDate.toDateString() === new Date().toDateString()) {
                                lastPingCell.textContent = "Today, " + lastPingDate.toLocaleTimeString();
                            } else if (lastPingDate.toDateString() === new Date(new Date().getTime() + 24 * 3600 * 1000).toDateString()) {
                                lastPingCell.textContent = "Tomorrow, " + lastPingDate.toLocaleTimeString();
                            } else if (lastPingDate.toDateString() === new Date(new Date().getTime() - 24 * 3600 * 1000).toDateString()) {
                                lastPingCell.textContent = "Yesterday, " + lastPingDate.toLocaleTimeString();
                            } else {
                                lastPingCell.textContent = formatDate(check.last_ping);
                            }
                        }

                        lastPingCell.style.textAlign = "center"; // Centra el texto
                        row.appendChild(lastPingCell);

                        // Celda para el número de pings
                        var numPingsCell = document.createElement("td");
                        numPingsCell.textContent = check.n_pings !== undefined ? check.n_pings : " ";
                        row.appendChild(numPingsCell);

                        // Celda para la duración en minutos y segundos
                        var durationCell = document.createElement("td");
                        durationCell.textContent = check.last_duration !== undefined ? formatElapsedTime(check.last_duration) : " ";
                        row.appendChild(durationCell);

                        tableBody.appendChild(row);
                    });
                }
            };


            httpRequest.open("GET", "https://healthchecks.io/api/v3/checks/");
            httpRequest.setRequestHeader("X-API-Key", key);
            httpRequest.send();
        }

        function mostrarHoraActual() {
            var horaActualElemento = document.getElementById("horaActual");
            var horaActual = new Date().toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit', second: '2-digit'});
            horaActualElemento.textContent = "Time: " + horaActual;
        }

        // Muestra la hora actual inicialmente
        mostrarHoraActual();

        // Obtiene y actualiza los datos inicialmente
        fetchDataAndUpdateTable();

        // Establece un intervalo para actualizar los datos cada x segundos definidos en intervalo refresco
        setInterval(fetchDataAndUpdateTable, intervalo_refresco);
        setInterval(mostrarHoraActual, intervalo_refresco);
    </script>

</body>
</html>
